## 3. 编写测试
*第一个测试用例*
~~~
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

class FirstJUnit5Tests {

    @Test
    void myFirstTest() {
        assertEquals(2, 1 + 1);
    }

}
~~~

### 3.1 注解说明
JUnit Jupiter 支持下面的注释来配置测试和扩展框架。
所有的核心注解都位于 junit-jupiter-api 模块的 [org.junit.jupiter.api](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/package-summary.html) 包中。

| 注解    |  描述  |
| --- | --- |
|  @Test  |  表示方法是一种测试方法。与JUnit 4的@ test注释不同，这个注释没有声明任何属性，因为JUnit Jupiter的测试扩展基于它们自己的专用注解进行操作。这些方法可以被继承，除非它们被重写。  |
|  @ParameterizedTest  |  表示方法是 [parameterized test](http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests)(参数化的测试)。这些方法可以被继承，除非它们被重写。  |
|  @RepeatedTest  |  表示方法是[ repeated test](http://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests)(重复测试)的测试模板。这些方法可以被继承，除非它们被重写。  |
|  @TestFactory  |  表示方法是用于[dynamic tests](http://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests)(动态测试)的测试工厂。这些方法可以被继承，除非它们被重写。  |
|  @TestInstance  |  用于为带注解的测试类配置[test instance lifecycle](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle)(测试实例生命周期)。这些方法可以被继承。  |
|  @TestTemplate  |  表示方法是用来根据注册[providers](http://junit.org/junit5/docs/current/user-guide/#extensions-test-templates)(提供者)返回的调用上下文多次调用的[template for test cases](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-templates)(测试用例的模板)。这些方法可以被继承，除非它们被重写。  |
|  @DisplayName  |  声明测试类或测试方法的自定义显示名称。这样的注解不能被继承。  |
|  @BeforeEach  |  表示在当前类中每个@test、@repeatedtest、@parameterizedtest 或 @testfactory方法执行前都要执行这个方法；类似于JUnit 4的@before。这些方法可以被继承，除非它们被重写。  |
|  @AfterEach  |  表示在当前类中每个@test、@repeatedtest、@parameterizedtest 或 @testfactory方法执行后都要执行这个方法;类似于JUnit 4的@after。这些方法可以被继承，除非它们被重写。  |
|  @BeforeAll  |  表示在当前类中只运行一次，在所有@test、@repeatedtest、@parameterizedtest 和 @testfactory方法执行前运行;类似于JUnit 4的@beforeclass。这些方法可以被继承的(除非它们是隐藏的或覆盖的)，并且必须是静态的(除非使用“per-class”[test instance lifecycle](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle) (测试实例生命周期))。  |
|  @AfterAll  |  表示在当前类中只运行一次，在所有@test、@repeatedtest、@parameterizedtest 和 @testfactory方法执行后运行;类似于JUnit 4的@afterclass。这些方法可以被继承(除非它们是隐藏的或覆盖的)，并且必须是静态的(除非使用“per-class”[test instance lifecycle](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle) (测试实例生命周期))。  |
|  @Nested  |  表示带注释的类是嵌套的非静态测试类。@beforeall 和 @afterall方法不能直接在 @Nested 测试类中使用，除非使用(除非使用“per-class”[test instance lifecycle](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle) (测试实例生命周期))。这样的注解不能被继承。  |
|  @Tag  |  用于在类或方法级别为筛选测试声明标记;类似于TestNG中的测试组或JUnit 4中的类别。此类注解是在类级别继承而不是在方法级继承的。  |
|  @Disabled  |  用于禁用测试类或测试方法;类似于JUnit 4的@ignore。这样的注解不能被继承。  |
|  @ExtendWith  |  用于注册自定义扩展。这些注释可以被继承。  |
方法被@test、@testtemplate、@repeatedtest、@beforeall、@afterall、@beforeeach 或 @aftereach注解了都不能返回一个值，都应该是 public void XXX(){ } 。
![警告](wran.png "警告")   | 有些注解目前可能是实验性的。有关详细信息，请参阅实[验性api](http://junit.org/junit5/docs/current/user-guide/#api-evolution-experimental-apis)中的表。

#### 3.1.1 元注解，组合注解
JUnit Jupiter注解可以用作元注解。这意味着您可以定义自己的组合注释，它将自动继承其元注释的语义。

例如，在您的代码库中(参见[Tagging and Filtering](http://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering)(标签和过滤))，您可以创建一个名为@fast的自定义组合注释，而不是复制和粘贴@tag("fast")。如下所示，@fast可以被用作替代@tag("fast")。
~~~
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.junit.jupiter.api.Tag;

@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Tag("fast")
public @interface Fast {
}
~~~

### 3.2. 标准测试类
*一个标准的测试用例*
~~~
import static org.junit.jupiter.api.Assertions.fail;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {

    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }

}
~~~
![警告](wran.png "警告")   | 测试类和测试方法都不需要写public(默认就是public的)。

### 3.3. DisplayName(显示名称)
测试类和测试方法可以声明自定义DisplayName(显示名称)——有空格、特殊字符，甚至是表情符号——这些都将由测试者和测试报告显示出来。
~~~
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("A special test case")
class DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("╯°□°）╯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("😱")
    void testWithDisplayNameContainingEmoji() {
    }

}
~~~

### 3.4. 断言（Assertions）
JUnit Jupiter 附带了许多JUnit 4所拥有的断言方法，并添加了一些可以很好地使用Java 8 lambdas的方法。所有的JUnit Jupiter断言都是在 org.junit.jupiter.Assertions (断言类)中的静态方法。
~~~
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.Test;

class AssertionsDemo {

    @Test
    void standardAssertions() {
        assertEquals(2, 2);
        assertEquals(4, 4, "The optional assertion message is now the last parameter.");
        assertTrue(2 == 2, () -> "Assertion messages can be lazily evaluated -- "
                + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and any
        // failures will be reported together.
        assertAll("person",
            () -> assertEquals("John", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
            () -> {
                String firstName = person.getFirstName();
                assertNotNull(firstName);

                // Executed only if the previous assertion is valid.
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("n"))
                );
            },
            () -> {
                // Grouped assertion, so processed independently
                // of results of first name assertions.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                // Executed only if the previous assertion is valid.
                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
        Throwable exception = assertThrows(IllegalArgumentException.class, () -> {
            throw new IllegalArgumentException("a message");
        });
        assertEquals("a message", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
        // The following assertion succeeds.
        assertTimeout(ofMinutes(2), () -> {
            // Perform task that takes less than 2 minutes.
        });
    }

    @Test
    void timeoutNotExceededWithResult() {
        // The following assertion succeeds, and returns the supplied object.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
        // The following assertion invokes a method reference and returns an object.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("hello world!", actualGreeting);
    }

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

    @Test
    void timeoutExceededWithPreemptiveTermination() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

    private static String greeting() {
        return "hello world!";
    }

}
~~~

#### 3.4.1. 第三方断言库
尽管JUnit Jupiter提供的断言工具对于许多测试场景来说已经足够了，但有时还需要更多的功能和额外的功能，如matchers。在这种情况下，JUnit团队建议使用诸如[AssertJ](http://joel-costigliola.github.io/assertj/)、[Hamcrest](http://hamcrest.org/JavaHamcrest/)、[Truth](http://google.github.io/truth/)等第三方断言库，因此开发人员可以自由使用他们选择的断言库。
例如，可以使用matchers和一个fluent API的组合使断言更具描述性和可读性。然而,JUnit Jupiter的 [org.junit.jupiter.Assertions](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html)断言类没有像JUnit 4的org.junit.Assert 那样提供一个assertThat()方法，Assert 类必须接受Hamcrest Matcher。取而代之的是，鼓励开发人员使用第三方断言库提供的对matchers的内置支持。
下面的示例演示如何在JUnit Jupiter测试中使用来自Hamcrest的assertThat()支持。只要将Hamcrest库添加到类路径中,可以静态导入方法比如assertThat(), is() 和 equalTo(),然后在assertWithHamcrestMatcher()方法里面进行测试。
~~~
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import org.junit.jupiter.api.Test;

class HamcrestAssertionDemo {

    @Test
    void assertWithHamcrestMatcher() {
        assertThat(2 + 1, is(equalTo(3)));
    }

}
~~~
当然，可以继续使用基于JUnit 4遗留的编程模型org.junit.Assert#assertThat进行测试。

### 3.5. 假设（Assumptions）
JUnit Jupiter 附带了JUnit 4提供的Assumptions（假设）方法的子集，并添加了一些可以很好地使用Java 8 lambdas的方法。所有的JUnit Jupiter假设都是 org.junit.jupiter.Assumptions 类的静态方法。
~~~
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV")));
        // remainder of test
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
        assumeTrue("DEV".equals(System.getenv("ENV")),
            () -> "Aborting test: not on developer workstation");
        // remainder of test
    }

    @Test
    void testInAllEnvironments() {
        assumingThat("CI".equals(System.getenv("ENV")),
            () -> {
                // perform these assertions only on the CI server
                assertEquals(2, 2);
            });

        // perform these assertions in all environments
        assertEquals("a string", "a string");
    }

}
~~~

### 3.6. 禁用测试（Disabled）
这是一个禁用测试类的测试用例。
~~~
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

@Disabled
class DisabledClassDemo {
    @Test
    void testWillBeSkipped() {
    }
}
~~~
这是一个带有禁用测试方法的测试用例。
~~~
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class DisabledTestsDemo {

    @Disabled
    @Test
    void testWillBeSkipped() {
    }

    @Test
    void testWillBeExecuted() {
    }
}
~~~
### 3.7. 标签和过滤（Tagging and Filtering）
可以对测试类和方法进行标记。这些标记稍后可以用于筛选 [test discovery and execution](http://junit.org/junit5/docs/current/user-guide/#running-tests)（测试发现和执行）。

#### 3.7.1. 标签的语法规则（Syntax Rules for Tags）
* 标记不能为`null`或`blank`。
* 一个修剪标签（trimmed tag）不能包含空格。
* 一个修剪标签（trimmed tag）不能包含ISO控制字符。
* 一个修剪标签（trimmed tag）不能包含以下保留字符
&nbsp; &nbsp;  `,` ,  `(` , `)` , `&` , `|` , `!`
![警告](wran.png "警告")  | 在上面的上下文中，“**修剪（trimmed）**”意味着引导和跟踪空白字符已经被删除。
~~~
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("fast")
@Tag("model")
class TaggingDemo {

    @Test
    @Tag("taxes")
    void testingTaxCalculation() {
    }

}
~~~

### 3.8. 测试实例的生命周期（Test Instance Lifecycle）
为了让单独的测试方法在隔离中被执行，并且为了避免由于可变测试实例状态而产生的意外副作用，JUnit在执行每个测试方法之前创建了一个新的测试类的实例(请参阅下面的说明作为测试方法的内容)。这个“per-method”测试实例生命周期是JUnit Jupiter上的默认行为，类似于所有以前的JUnit版本。

如果您希望JUnit Jupiter在同一个测试实例上执行所有的测试方法，只需用`@Testinstance(Lifecycle.PER_CLASS)`注解您的测试类。当使用此模式时，每个测试类将创建一个新的测试实例。因此，如果您的测试方法依赖于实例变量存储的状态，那么您可能需要在`@Beforeeach` 或 `@Aftereach` 方法中重置该状态。

“per-class”模式在默认的“per-method”模式下有一些额外的好处。具体地说，在“per-class”模式下，可以在非静态方法和接口默认方法上声明`@Beforeall`和`@Afterall`。因此，“per-class”模式也使`@Beforeall`和`@Afterall`方法可以在`@Nested` 测试类中使用。

如果您使用Kotlin编程语言编写测试，您可能也会发现，通过切换到“per-class”测试实例生命周期模式，可以更容易地实现`@Beforeall`和`@Afterall`方法。

![信息](info.png "信息")  | 在测试实例生命周期中，测试方法是用@test、@repeatedtest、@parameterizedtest、@testfactory或@testtemplate来注解的任何方法。

#### 3.8.1. 更改默认的测试实例生命周期（Changing the Default Test Instance Lifecycle）
如果测试类或测试接口没有用`@TestInstance`进行注解，JUnit Jupiter 将使用默认的生命周期模式。标准的默认模式是`PER_METHOD`;但是，可以更改整个测试计划执行的默认值。改变默认的测试实例的生命周期模式,只需将`junit.jupiter.testinstance.lifecycle.default`配置参数设置为`TestInstance.Lifecycle`中定义一个枚举常数的名称,忽略的情况。这可以作为一个JVM系统属性，在`LauncherDiscoveryRequest`中作为配置参数传递给 `Launcher`，或者通过JUnit平台配置文件(详细信息见配置参数（[Configuration Parameters](http://junit.org/junit5/docs/current/user-guide/#running-tests-config-params)）)。

例如，将默认测试实例生命周期模式设置为 `Lifecycle.PER_CLASS`。您可以使用以下系统属性启动JVM。
`-Djunit.jupiter.testinstance.lifecycle.default=per_class`

但是，请注意，通过JUnit Platform 配置文件设置默认的测试实例生命周期模式是一个更健壮的解决方案，因为配置文件可以与您的项目一起被检入版本控制系统，因此可以在ide和您的构建软件中使用。

将默认测试实例生命周期模式设置为  `Lifecycle.PER_CLASS `。通过JUnit Platform配置文件创建一个名为 `junit-platform.properties` 的文件。类路径的根属性(例如，`src/test/resources`)，内容如下。
`junit.jupiter.testinstance.lifecycle.default = per_class`

![警告](wran.png "警告")  | 更改默认的测试实例生命周期模式可能导致不可预测的结果和脆弱的构建，如果不一致的话。例如，如果构建将“per-class”语义配置为默认值，但是IDE中的测试使用“per-method”语义执行，这将使得在构建服务器上调试错误变得困难。因此建议在JUnit平台配置文件中更改默认值，而不是通过JVM系统属性。

### 3.9. 嵌套测试（Nested Tests）
嵌套测试赋予测试者更多的能力来表达几组测试之间的关系。这是一个精心设计的例子。
*测试堆栈的嵌套测试套件*
~~~
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.EmptyStackException;
import java.util.Stack;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

@DisplayName("A stack")
class TestingAStackDemo {

    Stack<Object> stack;

    @Test
    @DisplayName("is instantiated with new Stack()")
    void isInstantiatedWithNew() {
        new Stack<>();
    }

    @Nested
    @DisplayName("when new")
    class WhenNew {

        @BeforeEach
        void createNewStack() {
            stack = new Stack<>();
        }

        @Test
        @DisplayName("is empty")
        void isEmpty() {
            assertTrue(stack.isEmpty());
        }

        @Test
        @DisplayName("throws EmptyStackException when popped")
        void throwsExceptionWhenPopped() {
            assertThrows(EmptyStackException.class, () -> stack.pop());
        }

        @Test
        @DisplayName("throws EmptyStackException when peeked")
        void throwsExceptionWhenPeeked() {
            assertThrows(EmptyStackException.class, () -> stack.peek());
        }

        @Nested
        @DisplayName("after pushing an element")
        class AfterPushing {

            String anElement = "an element";

            @BeforeEach
            void pushAnElement() {
                stack.push(anElement);
            }

            @Test
            @DisplayName("it is no longer empty")
            void isNotEmpty() {
                assertFalse(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when popped and is empty")
            void returnElementWhenPopped() {
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when peeked but remains not empty")
            void returnElementWhenPeeked() {
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            }
        }
    }
}
~~~
![警告](wran.png "警告")  | 只有非静态嵌套类(即内部类)可以充当@Nested测试类。嵌套可以是任意深度的，而那些内部类被认为是测试类家族的完整成员，只有一个例外:`@BeforeAll` 和 `@AfterAll` 方法在默认情况下不工作。原因是Java不允许内部类中的 `static` 成员。但是，可以通过使用`@TestInstance(Lifecycle.PER_CLASS)`注解`@Nested`的测试类来规避这个限制(参见测试实例生命周期（[Test Instance Lifecycle](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle)）)。

### 3.10. 对构造函数和方法的依赖注入（Dependency Injection for Constructors and Methods）

在所有以前的JUnit版本中，测试构造函数或方法都不允许有参数(至少不允许使用标准的Runner实现)。作为JUnit Jupiter的主要变化之一，测试构造函数和方法现在都允许有参数。这允许更大的灵活性，并支持构造函数和方法的依赖注入。

[`ParameterResolver`](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/extension/ParameterResolver.html) （参数解析器）定义了用于测试扩展的API，它希望在运行时动态解析参数。如果测试构造函数或@Test, @TestFactory, @BeforeEach, @AfterEach, @BeforeAll 或者 @AfterAll方法接受一个参数，那么参数必须在运行时由注册的 `ParameterResolver` （参数解析器）解析。

目前有三个内置的解析器是自动注册的。
* TestInfoParameterResolver（测试信息参数解析器）:
如果一个方法的参数类型是[ `TestInfo `](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/TestInfo.html)， TestInfoParameterResolver将供应TestInfo对应当前测试的实例作为参数的值。然后，TestInfo可以用来检索关于当前测试的信息，比如测试的显示名称、测试类、测试方法或相关的标记。显示名称是一个技术名称，例如测试类或测试方法的名称，或者通过@DisplayName配置的自定义名称。
[TestInfo](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/TestInfo.html)作为一个从JUnit 4中替代TestName规则的替代程序。以下演示了如何将TestInfo注入到测试构造函数、@BeforeEach方法和@Test方法中。

~~~
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

@DisplayName("TestInfo Demo")
class TestInfoDemo {

    TestInfoDemo(TestInfo testInfo) {
        assertEquals("TestInfo Demo", testInfo.getDisplayName());
    }

    @BeforeEach
    void init(TestInfo testInfo) {
        String displayName = testInfo.getDisplayName();
        assertTrue(displayName.equals("TEST 1") || displayName.equals("test2()"));
    }

    @Test
    @DisplayName("TEST 1")
    @Tag("my-tag")
    void test1(TestInfo testInfo) {
        assertEquals("TEST 1", testInfo.getDisplayName());
        assertTrue(testInfo.getTags().contains("my-tag"));
    }

    @Test
    void test2() {
    }

}
~~~

* RepetitionInfoParameterResolver(重复信息参数解析器):
如果一个方法的参数是@RepeatedTest，@BeforeEach, 或 @AfterEach这种[ RepetitionInfo](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/RepetitionInfo.html)（重复信息）类型的方法,RepetitionInfoParameterResolver将提供一个RepetitionInfo实例。然后可以使用重复信息检索关于当前重复的信息以及相应的@RepeatedTest的重复次数。但是请注意,RepetitionInfoParameterResolver不能在@RepeatedTest的上下文中以外注册。看重复测试的例子（ [Repeated Test Examples](http://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests-examples)）。

* TestReporterParameterResolver（测试报告参数解析器）: 
如果一个方法的参数类型是TestReporter, TestReporterParameterResolver将提供一个实例。可以使用TestReporter发布关于当前测试运行的额外数据。数据可以通过TestExecutionListener.reportingEntryPublished()消费,因此可以通过ide查看，也可以包括在报告中。
在JUnit Jupiter 中，您应该使用TestReporter。在JUnit 4中您可以将信息打印到stdout或stderr在。使用@RunWith(JUnitPlatform.class)将输出所有已报告的条目到stdout。

~~~
import java.util.HashMap;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestReporter;

class TestReporterDemo {

    @Test
    void reportSingleValue(TestReporter testReporter) {
        testReporter.publishEntry("a key", "a value");
    }

    @Test
    void reportSeveralValues(TestReporter testReporter) {
        HashMap<String, String> values = new HashMap<>();
        values.put("user name", "dk38");
        values.put("award year", "1974");

        testReporter.publishEntry(values);
    }

}
~~~

![警告](warn.png "警告")  | 其他参数解析器必须通过通过@ExtendWith注册适当的扩展（[extensions](http://junit.org/junit5/docs/current/user-guide/#extensions)）来显式启用。

下面为一个定制的参数解析器（ParameterResolver）示例检查[MockitoExtension](https://github.com/junit-team/junit5-samples/tree/r5.0.2/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java)（模拟ito扩展程序）。虽然不打算做产品化的准备，但它展示了扩展模型和参数解析过程的简单和表现力。MyMockitoTest演示了如何将Mockito模型注入到@BeforeEach和@Test方法中。
~~~
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import com.example.Person;
import com.example.mockito.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MyMockitoTest {

    @BeforeEach
    void init(@Mock Person person) {
        when(person.getName()).thenReturn("Dilbert");
    }

    @Test
    void simpleTestWithInjectedMock(@Mock Person person) {
        assertEquals("Dilbert", person.getName());
    }

}
~~~
### 3.11. 测试接口和默认方法（Test Interfaces and Default Methods）
JUnit Jupiter 允许@Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate, @BeforeEach, @AfterEach在接口 `default` 方法上声明。如果测试接口或测试类被用`@TestInstance(Lifecycle.PER_CLASS)`注释(参见测试实例生命周期（[Test Instance Lifecycle](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle)）)，@BeforeAll 和 @AfterAll可以在测试接口`static`方法或接口`default` 方法中声明。这里有一些例子。
~~~
@TestInstance(Lifecycle.PER_CLASS)
interface TestLifecycleLogger {

    static final Logger LOG = Logger.getLogger(TestLifecycleLogger.class.getName());

    @BeforeAll
    default void beforeAllTests() {
        LOG.info("Before all tests");
    }

    @AfterAll
    default void afterAllTests() {
        LOG.info("After all tests");
    }

    @BeforeEach
    default void beforeEachTest(TestInfo testInfo) {
        LOG.info(() -> String.format("About to execute [%s]",
            testInfo.getDisplayName()));
    }

    @AfterEach
    default void afterEachTest(TestInfo testInfo) {
        LOG.info(() -> String.format("Finished executing [%s]",
            testInfo.getDisplayName()));
    }

}
~~~

~~~
interface TestInterfaceDynamicTestsDemo {

    @TestFactory
    default Collection<DynamicTest> dynamicTestsFromCollection() {
        return Arrays.asList(
            dynamicTest("1st dynamic test in test interface", () -> assertTrue(true)),
            dynamicTest("2nd dynamic test in test interface", () -> assertEquals(4, 2 * 2))
        );
    }

}
~~~

@ExtendWith 和 @Tag可以在测试接口上声明，以便实现接口的类自动继承其标记和扩展。在测试执行回调之前和之后，查看TimingExtension的源代码。

~~~
@Tag("timed")
@ExtendWith(TimingExtension.class)
interface TimeExecutionLogger {
}
~~~

在您的测试类中，您可以实现这些测试接口以使它们应用。

~~~
class TestInterfaceDemo implements TestLifecycleLogger,
        TimeExecutionLogger, TestInterfaceDynamicTestsDemo {

    @Test
    void isEqualValue() {
        assertEquals(1, 1, "is always equal");
    }

}
~~~

运行TestInterfaceDemo结果的输出类似如下:

~~~
:junitPlatformTest
INFO  example.TestLifecycleLogger - Before all tests
INFO  example.TestLifecycleLogger - About to execute [dynamicTestsFromCollection()]
INFO  example.TimingExtension - Method [dynamicTestsFromCollection] took 13 ms.
INFO  example.TestLifecycleLogger - Finished executing [dynamicTestsFromCollection()]
INFO  example.TestLifecycleLogger - About to execute [isEqualValue()]
INFO  example.TimingExtension - Method [isEqualValue] took 1 ms.
INFO  example.TestLifecycleLogger - Finished executing [isEqualValue()]
INFO  example.TestLifecycleLogger - After all tests

Test run finished after 190 ms
[         3 containers found      ]
[         0 containers skipped    ]
[         3 containers started    ]
[         0 containers aborted    ]
[         3 containers successful ]
[         0 containers failed     ]
[         3 tests found           ]
[         0 tests skipped         ]
[         3 tests started         ]
[         0 tests aborted         ]
[         3 tests successful      ]
[         0 tests failed          ]

BUILD SUCCESSFUL
~~~

这个特性的另一个可能的应用是编写接口契约的测试。例如，您可以为对象的`Object.equals`或`Comparable.compareTo`实现编写测试。

~~~
public interface Testable<T> {

    T createValue();

}
~~~

~~~
public interface EqualsContract<T> extends Testable<T> {

    T createNotEqualValue();

    @Test
    default void valueEqualsItself() {
        T value = createValue();
        assertEquals(value, value);
    }

    @Test
    default void valueDoesNotEqualNull() {
        T value = createValue();
        assertFalse(value.equals(null));
    }

    @Test
    default void valueDoesNotEqualDifferentValue() {
        T value = createValue();
        T differentValue = createNotEqualValue();
        assertNotEquals(value, differentValue);
        assertNotEquals(differentValue, value);
    }

}
~~~

~~~
public interface ComparableContract<T extends Comparable<T>> extends Testable<T> {

    T createSmallerValue();

    @Test
    default void returnsZeroWhenComparedToItself() {
        T value = createValue();
        assertEquals(0, value.compareTo(value));
    }

    @Test
    default void returnsPositiveNumberComparedToSmallerValue() {
        T value = createValue();
        T smallerValue = createSmallerValue();
        assertTrue(value.compareTo(smallerValue) > 0);
    }

    @Test
    default void returnsNegativeNumberComparedToSmallerValue() {
        T value = createValue();
        T smallerValue = createSmallerValue();
        assertTrue(smallerValue.compareTo(value) < 0);
    }

}
~~~

在您的测试类中，您可以实现两个契约接口，从而继承相应的测试。当然，您必须实现抽象方法。

~~~
class StringTests implements ComparableContract<String>, EqualsContract<String> {

    @Override
    public String createValue() {
        return "foo";
    }

    @Override
    public String createSmallerValue() {
        return "bar"; // 'b' < 'f' in "foo"
    }

    @Override
    public String createNotEqualValue() {
        return "baz";
    }

}
~~~

![警告](warn.png "警告")  | 上述测试仅仅是作为例子，因此不完整。

### 3.12. 重复测试（Repeated Tests）

JUnit Jupiter 通过使用 `@RepeatedTest` 来注释一个方法并指定所需重复的总数，从而提供了重复测试指定次数的能力。重复测试的每次调用行为都类似于执行常规的`@Test`方法，完全支持相同的生命周期回调和扩展。

下面的示例演示如何声明一个名为repeatedTest()的测试，该测试将自动重复10次。
~~~
@RepeatedTest(10)
void repeatedTest() {
    // ...
}
~~~

除了指定重复次数之外，还可以通过`@RepeatedTest`注释的name属性为每次重复配置一个自定义显示名称。此外，显示名称可以是由静态文本和动态占位符组合而成的模式。目前支持以下占位符。

* {displayName}: 显示`@RepeatedTest`方法的名称

* {currentRepetition}: 当前重复计数

* {totalRepetitions}: 重复的总数

一个给定的重复的默认显示名称是基于以下模式生成的:`"repetition {currentRepetition} of {totalRepetitions}"`。因此，对之前的重复使用的显示名`repeatedTest()`的例子是:`repetition 1 of 10`,`repetition 2 of 10`,等等。如果你想要显示的名称`@RepeatedTest`方法包含一种重复的名称,您可以定义自己的自定义模式或使用预定义的`RepeatedTest.LONG_DISPLAY_NAME`模式。后者等于`"{displayName} :: repetition {currentRepetition} of {totalRepetitions}"`这样就会显示出单个重复的名字`repeatedTest() :: repetition 1 of 10`, `repeatedTest() :: repetition 2 of 10`,等等。

为了检索关于当前重复的信息和编程的总重复次数，开发人员可以选择将 `RepetitionInfo `的实例注入到 `@RepeatedTest `， `@BeforeEach `，或 `@AfterEach `方法。

#### 3.12.1. 重复测试的例子（Repeated Test Examples）

本节末尾的`RepeatedTestsDemo`类演示了重复测试的几个例子。

`repeatedTest()`方法与前一节中的示例相同;然而,`repeatedTestWithRepetitionInfo()`演示了如何`RepetitionInfo`注入的实例测试访问当前重复测试的总数。

接下来的两个方法演示如何在每次重复的显示名称中包含`@RepeatedTest`方法的自定义`@DisplayName`。`customDisplayName()`将自定义显示名称与自定义模式组合在一起，然后使用`TestInfo`来验证生成的显示名称的格式。`Repeat!`（重复！）是来自`@DisplayName`声明的{displayName}，而1 / 1来自`{currentRepetition}/{totalRepetitions}`。相比之下,`customDisplayNameWithLongPattern()`使用前面提到的预定义`RepeatedTest.LONG_DISPLAY_NAME pattern`模式。

`repeatedTestInGerman()`演示了将重复测试的显示名称转换为外语的能力——在这个例子中是德语，为个别重复的名字命名，如:`Wiederholung 1 von 5`、`Wiederholung 2 von 5`等。

由于`beforeEach()`方法被用`@BeforeEach`，每个重复测试的每次重复之前都会被执行。通过将`TestInfo`和`RepetitionInfo` 注入到该方法中，我们就可以获得关于当前执行重复测试的信息。在信息日志级别上执行重复测试，可以得到以下输出结果。
~~~
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
~~~

~~~
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.logging.Logger;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.RepetitionInfo;
import org.junit.jupiter.api.TestInfo;

class RepeatedTestsDemo {

    private Logger logger = // ...

    @BeforeEach
    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {
        int currentRepetition = repetitionInfo.getCurrentRepetition();
        int totalRepetitions = repetitionInfo.getTotalRepetitions();
        String methodName = testInfo.getTestMethod().get().getName();
        logger.info(String.format("About to execute repetition %d of %d for %s", //
            currentRepetition, totalRepetitions, methodName));
    }

    @RepeatedTest(10)
    void repeatedTest() {
        // ...
    }

    @RepeatedTest(5)
    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {
        assertEquals(5, repetitionInfo.getTotalRepetitions());
    }

    @RepeatedTest(value = 1, name = "{displayName} {currentRepetition}/{totalRepetitions}")
    @DisplayName("Repeat!")
    void customDisplayName(TestInfo testInfo) {
        assertEquals(testInfo.getDisplayName(), "Repeat! 1/1");
    }

    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)
    @DisplayName("Details...")
    void customDisplayNameWithLongPattern(TestInfo testInfo) {
        assertEquals(testInfo.getDisplayName(), "Details... :: repetition 1 of 1");
    }

    @RepeatedTest(value = 5, name = "Wiederholung {currentRepetition} von {totalRepetitions}")
    void repeatedTestInGerman() {
        // ...
    }

}
~~~

当使用`ConsoleLauncher`或`junitPlatformTest`的Gradle插件时，启用了unicode主题，在随后的输出中执行`RepeatedTestsDemo`的结果。

~~~
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... :: repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
~~~

### 3.13. 参数化测试（Parameterized Tests）
参数化测试可以用不同的参数多次运行测试。它们像普通的`@Test`方法一样被声明，但是使用`@ParameterizedTest`注释。此外，您必须声明至少一个参数源，它将为每次调用提供参数。

警告：参数化测试目前是一个实验特性。有关详细信息，请参阅实验性api（[Experimental APIs](http://junit.org/junit5/docs/current/user-guide/#api-evolution-experimental-apis)）中的表。

~~~
@ParameterizedTest
@ValueSource(strings = { "racecar", "radar", "able was I ere I saw elba" })
void palindromes(String candidate) {
    assertTrue(isPalindrome(candidate));
}
~~~

这个参数化测试使用`@ValueSource`注释来指定字符串数组作为参数的来源。执行上述方法时，每个调用将分别报告。例如，`ConsoleLauncher`会输出类似以下的结果。
~~~
palindromes(String) ✔
├─ [1] racecar ✔
├─ [2] radar ✔
└─ [3] able was I ere I saw elba ✔
~~~

#### 3.13.1. 所需设置（Required Setup）

为了使用参数化测试，您需要添加 junit-jupiter-params构件的依赖项。有关详细信息，请参见依赖项元数据（[Dependency Metadata](http://junit.org/junit5/docs/current/user-guide/#dependency-metadata)）。

#### 3.13.2.参数的源（Sources of Arguments）

开箱即用的，JUnit Jupiter 提供了相当多的源注解。下面的每个小节提供了一个简短的概述，并为每个小节提供了一个示例。请参阅[org.junit.jupiter.params.provider](http://junit.org/junit5/docs/current/api/org/junit/jupiter/params/provider/package-summary.html) 包的JavaDoc文档。提供附加信息的提供者包。

#### @ValueSource

`@ValueSource`可能是最简单的来源之一。它允许您指定一组原始类型的文字(String、int、long或double)，并且只能用于每次调用时提供一个参数。
~~~
@ParameterizedTest
@ValueSource(ints = { 1, 2, 3 })
void testWithValueSource(int argument) {
    assertNotNull(argument);
}
~~~

#### @EnumSource
`@EnumSource` 提供了一种方便的方法来使用`Enum`常量。该注释提供了一个可选的`names`参数，允许您指定使用哪个常量。如果省略，所有的常量将在下面的例子中使用。
~~~
@ParameterizedTest
@EnumSource(TimeUnit.class)
void testWithEnumSource(TimeUnit timeUnit) {
    assertNotNull(timeUnit);
}
~~~

~~~
@ParameterizedTest
@EnumSource(value = TimeUnit.class, names = { "DAYS", "HOURS" })
void testWithEnumSourceInclude(TimeUnit timeUnit) {
    assertTrue(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));
}
~~~

`@EnumSource`注释还提供了一个可选的参数`mode`，使细粒度的控制常数被传递到测试方法。例如，可以在枚举常量池中排除名称，或者在以下示例中指定正则表达式。

~~~
@ParameterizedTest
@EnumSource(value = TimeUnit.class, mode = EXCLUDE, names = { "DAYS", "HOURS" })
void testWithEnumSourceExclude(TimeUnit timeUnit) {
    assertFalse(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));
    assertTrue(timeUnit.name().length() > 5);
}
~~~

~~~
@ParameterizedTest
@EnumSource(value = TimeUnit.class, mode = MATCH_ALL, names = "^(M|N).+SECONDS$")
void testWithEnumSourceRegex(TimeUnit timeUnit) {
    String name = timeUnit.name();
    assertTrue(name.startsWith("M") || name.startsWith("N"));
    assertTrue(name.endsWith("SECONDS"));
}
~~~

#### @MethodSource

`@MethodSource`允许您引用测试类的一个或多个工厂方法。这些方法必须返回流（`Stream`）、迭代（`Iterable`）、迭代器（`Iterator`）或参数数组。此外，这些方法不能接受任何参数。默认情况下，这些方法必须是静态的（`static` ），除非测试类被`@TestInstance(Lifecycle.PER_CLASS)`注解

如果只需要一个参数，则可以返回参数类型的流，如下面的示例所示。

~~~
@ParameterizedTest
@MethodSource("stringProvider")
void testWithSimpleMethodSource(String argument) {
    assertNotNull(argument);
}

static Stream<String> stringProvider() {
    return Stream.of("foo", "bar");
}
~~~

下面的示例还支持原始类型的流(DoubleStream、IntStream和LongStream)。

~~~
@ParameterizedTest
@MethodSource("range")
void testWithRangeMethodSource(int argument) {
    assertNotEquals(9, argument);
}

static IntStream range() {
    return IntStream.range(0, 20).skip(10);
}
~~~

如果一个测试方法声明多个参数，您则需要返回一个`Arguments`实例的集合或流，如下所示。请注意,`Arguments.of(Object…)`是在`Arguments`接口中定义的静态工厂方法。

~~~
@ParameterizedTest
@MethodSource("stringIntAndListProvider")
void testWithMultiArgMethodSource(String str, int num, List<String> list) {
    assertEquals(3, str.length());
    assertTrue(num >=1 && num <=2);
    assertEquals(2, list.size());
}

static Stream<Arguments> stringIntAndListProvider() {
    return Stream.of(
        Arguments.of("foo", 1, Arrays.asList("a", "b")),
        Arguments.of("bar", 2, Arrays.asList("x", "y"))
    );
}
~~~

#### @CsvSource

`@CsvSource`允许您以逗号分隔值来表达参数列表(即:`String` literals)。

~~~
@ParameterizedTest
@CsvSource({ "foo, 1", "bar, 2", "'baz, qux', 3" })
void testWithCsvSource(String first, int second) {
    assertNotNull(first);
    assertNotEquals(0, second);
}
~~~

`@CsvSource`使用单引号作（'）为其引用字符。在上面的例子和下表中看到`'baz,qux'`的为字符串。一个空的`''`引用的值结果为空字符串;然而，完全的空值被解释为`null`引用。如果目标类型的空引用是原始类型，就会引发`ArgumentConversionException`如表中的({ "foo, " }) 。

|  Example Input（输入例子）  |  Resulting Argument List（最终的参数列表）  |
| --- | --- |
|  @CsvSource({ "foo, bar" })  |  "foo", "bar"  |
| @CsvSource({ "foo, 'baz, qux'" }) | "foo", "baz, qux" |
| @CsvSource({ "foo, ''" }) |  "foo", "" |
| @CsvSource({ "foo, " }) | "foo", null |

#### @CsvFileSource

`@CsvFileSource`允许您从类路径中使用CSV文件。CSV文件中的每一行都产生一个参数化测试的调用。

~~~
@ParameterizedTest
@CsvFileSource(resources = "/two-column.csv")
void testWithCsvFileSource(String first, int second) {
    assertNotNull(first);
    assertNotEquals(0, second);
}
~~~

*two-column.csv*

~~~
foo, 1
bar, 2
"baz, qux", 3
~~~

注意：与`@CsvSource`中使用的语法相反，`@CsvFileSource`使用了双引号（“）作为引用字符。参见上面示例中的`“baz,qux”`值。一个空的，引用的值""结果为一个空字符串;然而，完全空值被解释为空引用（`null`）。如果空引用（`null`）的目标类型是原始类型，则引发`ArgumentConversionException`。

#### @ArgumentsSource

可以使用`@ArgumentsSource`指定自定义、可重用的`ArgumentsProvider`。

~~~
@ParameterizedTest
@ArgumentsSource(MyArgumentsProvider.class)
void testWithArgumentsSource(String argument) {
    assertNotNull(argument);
}

static class MyArgumentsProvider implements ArgumentsProvider {

    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of("foo", "bar").map(Arguments::of);
    }
}
~~~

#### 3.13.3. 参数转换（Argument Conversion）

##### 隐式转换（Implicit Conversion）

为了支持像@CsvSource这样的用例，JUnit Jupiter 提供了一些内置隐式类型转换器。转换过程取决于每个方法参数的声明类型。

例如，如果一个`@ParameterizedTest`声明了一个`TimeUnit`类型的参数，而被声明的源提供的实际类型是一个字符串，则该字符串将自动转换为相应的`TimeUnit`枚举常量。

~~~
@ParameterizedTest
@ValueSource(strings = "SECONDS")
void testWithImplicitArgumentConversion(TimeUnit argument) {
    assertNotNull(argument.name());
}
~~~

字符串实例目前可以隐式转换为以下目标类型。


|  Target Type  |  Example  |
| --- | --- |
|  boolean/Boolean  |  "true" → true  |
|  byte/Byte  |  "1" → (byte) 1  |
|  char/Character  |  "o" → 'o'  |
|  short/Short  |  	"1" → (short) 1  |
|  int/Integer  |  "1" → 1  |
|  long/Long  |  "1" → 1L  |
|  float/Float  |  "1.0" → 1.0f  |
| double/Double | "1.0" → 1.0d  |
| Enum subclass | "SECONDS" → TimeUnit.SECONDS |
| java.time.Instant | "1970-01-01T00:00:00Z" → Instant.ofEpochMilli(0) |
| java.time.LocalDate | "2017-03-14" → LocalDate.of(2017, 3, 14) |
| java.time.LocalDateTime | "2017-03-14T12:34:56.789" → LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000) |
| java.time.LocalTime | "12:34:56.789" → LocalTime.of(12, 34, 56, 789_000_000) |
| java.time.OffsetDateTime | "2017-03-14T12:34:56.789Z" → OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC) |
| java.time.OffsetTime | "12:34:56.789Z" → OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC) |
| java.time.Year | "2017" → Year.of(2017) |
| java.time.YearMonth | "2017-03" → YearMonth.of(2017, 3) |
| java.time.ZonedDateTime | "2017-03-14T12:34:56.789Z" → ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC) |

##### 显式转换（Explicit Conversion）

与其使用隐式参数转换，您可以显式地指定一个`ArgumentConverter`来使用`@ConvertWith`注释来使用某个参数，比如下面的例子。

~~~
@ParameterizedTest
@EnumSource(TimeUnit.class)
void testWithExplicitArgumentConversion(@ConvertWith(ToStringArgumentConverter.class) String argument) {
    assertNotNull(TimeUnit.valueOf(argument));
}

static class ToStringArgumentConverter extends SimpleArgumentConverter {

    @Override
    protected Object convert(Object source, Class<?> targetType) {
        assertEquals(String.class, targetType, "Can only convert to String");
        return String.valueOf(source);
    }
}
~~~

显式参数转换是由测试者实现的。因此,junit-jupiter-params只提供了一个显式参数转换类：`JavaTimeArgumentConverter`,也可以作为一种参考实现。这是通过使用注释`JavaTimeConversionPattern`组成例子。

~~~
@ParameterizedTest
@ValueSource(strings = { "01.01.2017", "31.12.2017" })
void testWithExplicitJavaTimeConverter(@JavaTimeConversionPattern("dd.MM.yyyy") LocalDate argument) {
    assertEquals(2017, argument.getYear());
}
~~~

#### 3.13.4. 自定义显示的名字（Customizing Display Names）

默认情况下，参数化测试调用的显示名称包含调用索引和特定调用的所有参数的字符串表示。但是，您可以通过以下示例中的`@ParameterizedTest`注释的`name`属性来定制调用显示名称。

~~~
@DisplayName("Display name of container")
@ParameterizedTest(name = "{index} ==> first=''{0}'', second={1}")
@CsvSource({ "foo, 1", "bar, 2", "'baz, qux', 3" })
void testWithCustomDisplayNames(String first, int second) {
}
~~~

在使用`ConsoleLauncher`执行上述方法时，您将看到类似如下的输出。

~~~
Display name of container ✔
├─ 1 ==> first='foo', second=1 ✔
├─ 2 ==> first='bar', second=2 ✔
└─ 3 ==> first='baz, qux', second=3 ✔
~~~

在自定义显示名称中支持以下占位符。


|  Placeholder  |  Description  |
| --- | --- |
|  {index}  |  the current invocation index (1-based)  |
|  {arguments}  |  the complete, comma-separated arguments list  |
|  {0}, {1}, …  |  an individual argument  |

#### 3.13.5. 生命周期和互操作性（Lifecycle and Interoperability）

参数化测试的每次调用都有与常规的`@Test`方法相同的生命周期。例如，`@BeforeEach`方法将在每次调用之前执行。与动态测试（[Dynamic Tests](http://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests)）类似，调用将在IDE的测试树中逐一显示。您可以在同一个测试类中混合常规的@Test方法和@ParameterizedTest方法。

您可以使用`@ParameterizedTest`方法使用`ParameterResolver`扩展。但是，由参数源解决的方法参数需要首先出现在参数列表中。由于测试类可能包含常规测试，以及带有不同参数列表的参数化测试，来自参数源的值不会解析为生命周期方法(例如`@BeforeEach`)和测试类构造函数。

~~~
@BeforeEach
void beforeEach(TestInfo testInfo) {
    // ...
}

@ParameterizedTest
@ValueSource(strings = "foo")
void testWithRegularParameterResolver(String argument, TestReporter testReporter) {
    testReporter.publishEntry("argument", argument);
}

@AfterEach
void afterEach(TestInfo testInfo) {
    // ...
}
~~~

### 3.14. 测试模板（Test Templates）

[`@TestTemplate`](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/TestTemplate.html)方法不是常规的测试用例，而是测试用例的模板。因此，根据注册提供者返回的调用上下文的数量，它被设计为多次调用。因此,它必须使用与注册[`TestTemplateInvocationContextProvider`](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html)的扩展。测试模板方法的每次调用都像一个常规的`@Test`方法的执行，完全支持相同的生命周期回调和扩展。请参考为使用示例提供测试模板的调用上下文（[`Providing Invocation Contexts for Test Templates`](http://junit.org/junit5/docs/current/user-guide/#extensions-test-templates)）。

### 3.15. 动态测试（Dynamic Tests）

在注释中描述的JUnit Jupiter 上的标准`@Test`注解与JUnit 4中的`@Test`注释非常相似。都描述了实现测试用例的方法。这些测试用例是静态的，它们在编译时被完全指定，而且它们的行为不能被运行时发生的任何事情改变。假设提供了一种基本形式的动态行为，但在他们的表现力上却有意限制。

除了这些标准测试之外，JUnit Jupiter还引入了一种全新的测试编程模型。这种新的测试是一个动态测试，它是在运行时通过一个与`@TestFactory`注释的工厂方法生成的。

与`@Test`方法相比，`@TestFactory`方法本身并不是一个测试用例，而是一个用于测试用例的工厂。因此，动态测试是工厂的产品。从技术上讲，`@TestFactory`方法必须返回动态节点实例的流（`Stream`）、集合（`Collection`）、迭代器（`Iterable`、`Iterator`）的`DynamicNode`实例，`DynamicNode`的实例子类是`DynamicContainer`和`DynamicTest`。`DynamicContainer`实例由一个显示名称和一个动态子节点列表组成，可以创建任意嵌套的动态节点层次结构。然后，`DynamicTest`实例将被延迟执行，从而支持动态甚至不确定的测试用例生成。

`@TestFactory`返回的任何流（`Stream`）都将通过调用`stream.close()`来适当地关闭，这样就可以安全地使用诸如`Files.lines()`这样的资源。

与`@Test`方法一样，`@TestFactory`方法不能是私有（`private`）的或静态的（`static`），也可以选择性地声明由参数解析器（`ParameterResolvers`）解析的参数。

`DynamicTest`是在运行时生成的测试用例。它由一个显示名称组成。`Executable. Executable`是一个`@FunctionalInterface`，这意味着动态测试的实现可以作为lambda表达式或方法引用。

##### 注意 | 动态测试生命周期
动态测试的执行生命周期与标准`@Test`用例的执行生命周期完全不同。具体地说，对于单个动态测试没有生命周期回调。这意味着`@BeforeEach`和`@AfterEach`方法及其相应的扩展回调是为`@TestFactory`方法执行的，而不是为每个动态测试执行的。换句话说，如果您从测试实例中的一个lambda表达式中的测试实例中访问字段，那么这些字段将不会被相同的`@TestFactory`方法所生成的单个动态测试执行的回调方法或扩展所重置。

在JUnit Jupiter 5.0.2中，动态测试必须始终由工厂方法创建；然而，这可能会在稍后的版本中得到注册工具的补充。

注意 | 动态测试目前是一个实验特性。有关详细信息，请参阅实验性api（[Experimental APIs](http://junit.org/junit5/docs/current/user-guide/#api-evolution-experimental-apis)）中的表。

#### 3.15.1. 动态测试的例子（Dynamic Test Examples）

下面的`DynamicTestsDemo`类演示了几个测试工厂和动态测试的例子。

第一个方法返回无效的返回类型。由于无法在编译时检测到无效的返回类型，因此在运行时检测到`JUnitException`。

接下来的五个方法是非常简单的示例，它们演示了一个`Collection`、`Iterable`、`Iterator`或`DynamicTest`实例`Stream`的生成。这些例子中的大多数并没有真正表现出动态行为，只是原则上演示了受支持的返回类型。然而,`dynamicTestsFromStream()`和`dynamicTestsFromIntStream()`证明是多么容易生成动态测试对于一个给定的字符串或一系列输入数字。

下一个方法是真正的动态测试。`generateRandomNumberOfTests()`实现`Iterator`生成随机数,显示名称生成器和一个测试执行者,然后提供所有三个`DynamicTest.stream()`。尽管`generateRandomNumberOfTests()`的非确定性行为是在冲突与测试重复性,因此应小心使用,它的表现的是动态测试的权力。

最后一个方法使用`DynamicContainer`生成一个嵌套的动态测试层次结构。

~~~
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.function.Function;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.junit.jupiter.api.DynamicNode;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.function.ThrowingConsumer;

class DynamicTestsDemo {

    // This will result in a JUnitException!
    @TestFactory
    List<String> dynamicTestsWithInvalidReturnType() {
        return Arrays.asList("Hello");
    }

    @TestFactory
    Collection<DynamicTest> dynamicTestsFromCollection() {
        return Arrays.asList(
            dynamicTest("1st dynamic test", () -> assertTrue(true)),
            dynamicTest("2nd dynamic test", () -> assertEquals(4, 2 * 2))
        );
    }

    @TestFactory
    Iterable<DynamicTest> dynamicTestsFromIterable() {
        return Arrays.asList(
            dynamicTest("3rd dynamic test", () -> assertTrue(true)),
            dynamicTest("4th dynamic test", () -> assertEquals(4, 2 * 2))
        );
    }

    @TestFactory
    Iterator<DynamicTest> dynamicTestsFromIterator() {
        return Arrays.asList(
            dynamicTest("5th dynamic test", () -> assertTrue(true)),
            dynamicTest("6th dynamic test", () -> assertEquals(4, 2 * 2))
        ).iterator();
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromStream() {
        return Stream.of("A", "B", "C")
            .map(str -> dynamicTest("test" + str, () -> { /* ... */ }));
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromIntStream() {
        // Generates tests for the first 10 even integers.
        return IntStream.iterate(0, n -> n + 2).limit(10)
            .mapToObj(n -> dynamicTest("test" + n, () -> assertTrue(n % 2 == 0)));
    }

    @TestFactory
    Stream<DynamicTest> generateRandomNumberOfTests() {

        // Generates random positive integers between 0 and 100 until
        // a number evenly divisible by 7 is encountered.
        Iterator<Integer> inputGenerator = new Iterator<Integer>() {

            Random random = new Random();
            int current;

            @Override
            public boolean hasNext() {
                current = random.nextInt(100);
                return current % 7 != 0;
            }

            @Override
            public Integer next() {
                return current;
            }
        };

        // Generates display names like: input:5, input:37, input:85, etc.
        Function<Integer, String> displayNameGenerator = (input) -> "input:" + input;

        // Executes tests based on the current input value.
        ThrowingConsumer<Integer> testExecutor = (input) -> assertTrue(input % 7 != 0);

        // Returns a stream of dynamic tests.
        return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);
    }

    @TestFactory
    Stream<DynamicNode> dynamicTestsWithContainers() {
        return Stream.of("A", "B", "C")
            .map(input -> dynamicContainer("Container " + input, Stream.of(
                dynamicTest("not null", () -> assertNotNull(input)),
                dynamicContainer("properties", Stream.of(
                    dynamicTest("length > 0", () -> assertTrue(input.length() > 0)),
                    dynamicTest("not empty", () -> assertFalse(input.isEmpty()))
                ))
            )));
    }

}
~~~



